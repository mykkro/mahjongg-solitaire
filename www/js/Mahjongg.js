
var MahjonggLayouts = {
	standard144: [
			{ x: 2, y:14, z:0}, { x: 4, y:14, z:0}, { x: 6, y:14, z:0}, { x: 8, y:14, z:0}, { x: 10, y:14, z:0}, { x: 12, y:14, z:0}, { x: 14, y:14, z:0}, { x: 16, y:14, z:0}, { x: 18, y:14, z:0}, { x: 20, y:14, z:0}, { x: 22, y:14, z:0}, { x: 24, y:14, z:0}, 
			{ x: 6, y:12, z:0}, { x: 8, y:12, z:0}, { x: 10, y:12, z:0}, { x: 12, y:12, z:0}, { x: 14, y:12, z:0}, { x: 16, y:12, z:0}, { x: 18, y:12, z:0}, { x: 20, y:12, z:0}, 
			{ x: 4, y:10, z:0}, { x: 6, y:10, z:0}, { x: 8, y:10, z:0}, { x: 10, y:10, z:0}, { x: 12, y:10, z:0}, { x: 14, y:10, z:0}, { x: 16, y:10, z:0}, { x: 18, y:10, z:0}, { x: 20, y:10, z:0}, { x: 22, y:10, z:0}, 
			{ x: 0, y:7, z:0}, 
			{ x: 2, y:8, z:0}, { x: 4, y:8, z:0}, { x: 6, y:8, z:0}, { x: 8, y:8, z:0}, { x: 10, y:8, z:0}, { x: 12, y:8, z:0}, { x: 14, y:8, z:0}, { x: 16, y:8, z:0}, { x: 18, y:8, z:0}, { x: 20, y:8, z:0}, { x: 22, y:8, z:0}, { x: 24, y:8, z:0}, 
			{ x: 2, y:6, z:0}, { x: 4, y:6, z:0}, { x: 6, y:6, z:0}, { x: 8, y:6, z:0}, { x: 10, y:6, z:0}, { x: 12, y:6, z:0}, { x: 14, y:6, z:0}, { x: 16, y:6, z:0}, { x: 18, y:6, z:0}, { x: 20, y:6, z:0}, { x: 22, y:6, z:0}, { x: 24, y:6, z:0}, 
		    { x: 26, y:7, z:0}, { x: 28, y:7, z:0}, 
			{ x: 4, y:4, z:0}, { x: 6, y:4, z:0}, { x: 8, y:4, z:0}, { x: 10, y:4, z:0}, { x: 12, y:4, z:0}, { x: 14, y:4, z:0}, { x: 16, y:4, z:0}, { x: 18, y:4, z:0}, { x: 20, y:4, z:0}, { x: 22, y:4, z:0}, 
			{ x: 6, y:2, z:0}, { x: 8, y:2, z:0}, { x: 10, y:2, z:0}, { x: 12, y:2, z:0}, { x: 14, y:2, z:0}, { x: 16, y:2, z:0}, { x: 18, y:2, z:0}, { x: 20, y:2, z:0}, 
			{ x: 2, y:0, z:0}, { x: 4, y:0, z:0}, { x: 6, y:0, z:0}, { x: 8, y:0, z:0}, { x: 10, y:0, z:0}, { x: 12, y:0, z:0}, { x: 14, y:0, z:0}, { x: 16, y:0, z:0}, { x: 18, y:0, z:0}, { x: 20, y:0, z:0}, { x: 22, y:0, z:0}, { x: 24, y:0, z:0}, 

			{ x: 8, y:12, z:1}, { x: 10, y:12, z:1}, { x: 12, y:12, z:1}, { x: 14, y:12, z:1}, { x: 16, y:12, z:1}, { x: 18, y:12, z:1},
			{ x: 8, y:10, z:1}, { x: 10, y:10, z:1}, { x: 12, y:10, z:1}, { x: 14, y:10, z:1}, { x: 16, y:10, z:1}, { x: 18, y:10, z:1},
			{ x: 8, y:8, z:1}, { x: 10, y:8, z:1}, { x: 12, y:8, z:1}, { x: 14, y:8, z:1}, { x: 16, y:8, z:1}, { x: 18, y:8, z:1},
			{ x: 8, y:6, z:1}, { x: 10, y:6, z:1}, { x: 12, y:6, z:1}, { x: 14, y:6, z:1}, { x: 16, y:6, z:1}, { x: 18, y:6, z:1},
			{ x: 8, y:4, z:1}, { x: 10, y:4, z:1}, { x: 12, y:4, z:1}, { x: 14, y:4, z:1}, { x: 16, y:4, z:1}, { x: 18, y:4, z:1},
			{ x: 8, y:2, z:1}, { x: 10, y:2, z:1}, { x: 12, y:2, z:1}, { x: 14, y:2, z:1}, { x: 16, y:2, z:1}, { x: 18, y:2, z:1},

			{ x: 10, y:10, z:2}, { x: 12, y:10, z:2}, { x: 14, y:10, z:2}, { x: 16, y:10, z:2},
			{ x: 10, y:8, z:2}, { x: 12, y:8, z:2}, { x: 14, y:8, z:2}, { x: 16, y:8, z:2},
			{ x: 10, y:6, z:2}, { x: 12, y:6, z:2}, { x: 14, y:6, z:2}, { x: 16, y:6, z:2},
			{ x: 10, y:4, z:2}, { x: 12, y:4, z:2}, { x: 14, y:4, z:2}, { x: 16, y:4, z:2},

			{ x: 12, y:8, z:3}, { x: 14, y:8, z:3},
			{ x: 12, y:6, z:3}, { x: 14, y:6, z:3},

			{ x: 13, y:7, z:4}
		]
}

var MahjonggTileset = {
	standard: {
		tileTypes: ["bamboo", "man", "pin", "wind", "dragon", "flower", "season"],

		tiles: {
			"bamboo": {
				"icons": ["bamboo1.png", "bamboo2.png", "bamboo3.png", "bamboo4.png", "bamboo5.png", "bamboo6.png", "bamboo7.png", "bamboo8.png", "bamboo9.png"],
				"countInSet": 4,
				"matchesWithAnother": false
			},
			"man": {
				"icons": ["man1.png", "man2.png", "man3.png", "man4.png", "man5.png", "man6.png", "man7.png", "man8.png", "man9.png"],
				"countInSet": 4,
				"matchesWithAnother": false
			},
			"pin": {
				"icons": ["pin1.png", "pin2.png", "pin3.png", "pin4.png", "pin5.png", "pin6.png", "pin7.png", "pin8.png", "pin9.png"],
				"countInSet": 4,
				"matchesWithAnother": false
			},
			"wind": {
				"icons": ["wind-east.png", "wind-north.png", "wind-south.png", "wind-west.png"],
				"countInSet": 4,
				"matchesWithAnother": false
			},
			"dragon": {
				"icons": ["dragon-chun.png", "dragon-green.png", "dragon-haku.png"],
				"countInSet": 4,
				"matchesWithAnother": false
			},
			"flower": {
				"icons": ["flower-bamboo.png", "flower-chrysanthemum.png", "flower-orchid.png", "flower-plum.png"],
				"countInSet": 1,
				"matchesWithAnother": true
			},
			"season": {
				"icons": ["season-autumn.png", "season-spring.png", "season-summer.png", "season-winter.png"],
				"countInSet": 1,
				"matchesWithAnother": true
			}
		},

	}
}

var Mahjongg = Base.extend({

	// 144 tiles
	// bamboo: 9 types * 4 = 36
	// wheels: 9 types * 4 = 36
	// numbers: 9 types * 4 = 36
	// -- 108
	// 4 winds: 4 types, 4 of each = 16
	// 3 dragons, 4 of each = 12
	// 4 flowers, 1 of each, each matches each other = 4
	// 4 seasons, 1 of each, each matches each other = 4

	defaultOptions: {
		layout: MahjonggLayouts.standard144,
		tileset: MahjonggTileset.standard,
		highlightDuration: 1000,
		boardDiv: "board2",
		layersColors: [
			"rgba(255,255,255,0)",
			"rgba(255,0,255,0.15)",
			"rgba(255,255,0,0.15)",
			"rgba(0,255,255,0.15)",
			"rgba(255,0,0,0.15)"
		]
	},

	constructor: function(opts) {

		var o = opts || this.defaultOptions;
		this.opts = o;

		this.highlightDuration = o.highlightDuration || 1000;
		var layout = o.layout || MahjonggLayouts.standard144;

		// deep copy array...
		this.layout = $.extend(true, [], layout);
		this.tiles = o.tileset.tiles;
		this.tileTypes = o.tileset.tileTypes;
		this.layersColors = o.layersColors;

		for(var i=0; i<this.layout.length; i++) {
			this.layout[i].index = i;
			this.layout[i].tilesBelow = []
			this.layout[i].tilesAbove = []
			this.layout[i].tilesOnLeft = []
			this.layout[i].tilesOnRight = []
			this.layout[i].occupiedBy = null;
		}

		this.findAdjacentPositions();

		this.STATE = 0;
		this.firstSelectedPos = null;
		this.firstDelectedTile = null;
		this.secondSelectedPos = null;
		this.secondSelectedTile = null;

	},
		
	makeTileList: function() {
		var out = []
		for(var i=0; i<this.tileTypes.length; i++) {
			var tt = this.tiles[this.tileTypes[i]]
			for(var j=0; j<tt.icons.length; j++) {
				for(k=0; k<tt.countInSet; k++) {
					out.push({type:this.tileTypes[i], index: j, name: this.tileTypes[i]+(j+1)})
				}
			}
		}
		return out;
	},		
		
	makeTile: function(type, index, x, y, z) {				
		var icon = $("<div>").addClass("tile").css({
			"position": "absolute",
			"background-image": "url(img/tiles/"+this.tiles[type].icons[index]+")"
		})
		var overlay = $("<div>").addClass("tile-overlay").css({
			"position": "absolute",
			"background-color": this.layersColors[z]
		})
		var both = $("<div>").addClass("tile-wrapper").css({
			"position": "absolute",
			"left": (42*x - 7*z)+"px",
			"top": (64*y + 14*z)+"px"
		}).append(icon, overlay)
		return both;
	},

	// find adjacencies...
	findAdjacentPositions: function() {
		for(var i=0; i<this.layout.length; i++) {
			var currentPos = this.layout[i]
			for(var j=0; j<this.layout.length; j++) {
				if(j != i) {
					var otherPos = this.layout[j]
					this.testAdjacency(currentPos, otherPos)
				}
			}
		}
	},

	testAdjacency: function(pos, otherPos) {
		// is other position below?
		if(otherPos.z+1 == pos.z && Math.abs(pos.x-otherPos.x)<=1 && Math.abs(pos.y-otherPos.y)<=1) {
			pos.tilesBelow.push(otherPos.index);
			otherPos.tilesAbove.push(pos.index);
		}
		if(otherPos.z == pos.z) {
			// is other position on the left?
			if(otherPos.x+2 == pos.x && Math.abs(pos.y-otherPos.y)<=1) {
				pos.tilesOnLeft.push(otherPos.index);
			}
			// is other position on the right?
			if(otherPos.x-2 == pos.x && Math.abs(pos.y-otherPos.y)<=1) {
				pos.tilesOnRight.push(otherPos.index);
			}
		}
	},
	start: function() {
		var tileList = this.makeTileList();

		var tmpArray = []
		var newTileList = []
		for(var i=0; i<72; i++) {
			tmpArray.push(i);
			newTileList.push(0)
			newTileList.push(0)
		}
		this.shuffle(tmpArray);
		console.log(tmpArray);
		for(var i=0; i<72; i++) {
			var ind = tmpArray[i]
			newTileList[2*i] = tileList[2*ind];
			newTileList[2*i+1] = tileList[2*ind+1];
		}
		tileList = newTileList;

		// fill the free positions...
		for(var i=0; i<tileList.length; i++) {
			this.placeTile(tileList[i])
		}
		// all tiles set!
		console.log("All positions occupied!")
		console.log(this.layout)

		this.tileList = tileList;
		var self = this;
		for(var i=0; i<this.layout.length; i++) {
			(function() {
				var pos = self.layout[i]
				var tile = pos.occupiedBy; // tileList[i]
				// drawTile(pos.x, pos.y, tile.name)
				var ttt =self.makeTile(tile.type, tile.index, pos.x, pos.y, pos.z);
				ttt.click(function() {
					self.onTileClicked(ttt, tile, pos);
				})
				$("#"+self.opts.boardDiv).append(ttt);
			})();

		}


		// test if positions are free
		/*
		for(var i=0; i<layout.length; i++) {
			console.log(i, layout[i], isPositionFree(i))
		}
		*/
		var occupiedPositions = {}
		var freePositions = {}
		var freePositionCount = 0


	},

	isPositionFree: function(index) {
		var pos = this.layout[index]
		if(pos.occupiedBy) return false;
		// is position valid?
		// position is valid if: 
		//  - all positions below are occupied
		//  and
		// - row is empty (if we go as far as we can to the left/right, we encounter only empty positions)
		// or - we bave occupied all the left neighbors or all the right neighbors
		return this.areAllBelowPositionsOccupied(index) && (this.isRowEmpty(index) || this.areAllLeftPositionsOccupied(index) || this.areAllRightPositionsOccupied(index))		
	},

	areAllBelowPositionsOccupied: function(index) {
		var pos = this.layout[index]
		for(var i=0; i<pos.tilesBelow.length; i++) {
			var otherPos = this.layout[pos.tilesBelow[i]]
			if(!otherPos.occupiedBy) return false;
		}
		return true;
	},

	areAllAbovePositionsFree: function(index) {
		var pos = this.layout[index]
		for(var i=0; i<pos.tilesAbove.length; i++) {
			var otherPos = this.layout[pos.tilesAbove[i]]
			if(otherPos.occupiedBy) return false;
		}
		return true;
	},

	areAllLeftPositionsOccupied: function(index) {
		var pos = this.layout[index]
		for(var i=0; i<pos.tilesOnLeft.length; i++) {
			var otherPos = this.layout[pos.tilesOnLeft[i]]
			if(!otherPos.occupiedBy) return false;
		}
		return true;
	},

	areAllRightPositionsOccupied: function(index) {
		var pos = this.layout[index]
		for(var i=0; i<pos.tilesOnRight.length; i++) {
			var otherPos = this.layout[pos.tilesOnRight[i]]
			if(!otherPos.occupiedBy) return false;
		}
		return true;
	},

	areAllLeftPositionsFree: function(index) {
		var pos = this.layout[index]
		for(var i=0; i<pos.tilesOnLeft.length; i++) {
			var otherPos = this.layout[pos.tilesOnLeft[i]]
			if(otherPos.occupiedBy) return false;
		}
		return true;
	},

	areAllRightPositionsFree: function(index) {
		var pos = this.layout[index]
		for(var i=0; i<pos.tilesOnRight.length; i++) {
			var otherPos = this.layout[pos.tilesOnRight[i]]
			if(otherPos.occupiedBy) return false;
		}
		return true;
	},

	isRowEmpty: function(index, direction) {
		var pos = this.layout[index]
		var out = !pos.occupiedBy
		if(out) {
			if(!direction || direction=="left") {
				for(var i=0; i<pos.tilesOnLeft.length; i++) {
					var otherPos = this.layout[pos.tilesOnLeft[i]]
					if(!this.isRowEmpty(otherPos.index, "left")) return false;
				}
			}
			if(!direction || direction=="right") {
				for(var i=0; i<pos.tilesOnRight.length; i++) {
					var otherPos = this.layout[pos.tilesOnRight[i]]
					if(!this.isRowEmpty(otherPos.index, "right")) return false;
				}
			}
		}
		return out;
	},

	testTilesIfMatching: function(tile1, tile2) {
		var tt1 = this.tiles[tile1.type];
		var tt2 = this.tiles[tile2.type];
		console.log(tile1, tile2, tt1, tt2);
		return (tile1.type == tile2.type) && (tt1.matchesWithAnother || (tile1.index == tile2.index));
	},

	occupyPosition: function(index, tile) {
		var pos = this.layout[index]
		pos.occupiedBy = tile
	},


	placeTile: function(tile) {
		// find free place
		var ind = Math.floor(Math.random()*144)
		while(!this.isPositionFree(ind)) {
			ind = ( ind + 1 ) % 144;
		}
		// found one!
		this.occupyPosition(ind, tile)
	},

	// randomize tiles...
	shuffle: function(array) {
	  var currentIndex = array.length, temporaryValue, randomIndex ;

	  // While there remain elements to shuffle...
	  while (0 !== currentIndex) {

	    // Pick a remaining element...
	    randomIndex = Math.floor(Math.random() * currentIndex);
	    currentIndex -= 1;

	    // And swap it with the current element.
	    temporaryValue = array[currentIndex];
	    array[currentIndex] = array[randomIndex];
	    array[randomIndex] = temporaryValue;
	  }

	  return array;
	},

	canTileBeRemoved: function(index) {
		var pos = this.layout[index]
		var tile = pos.occupiedBy; 
		if(!tile) return false;
		var leftFree = this.areAllLeftPositionsFree(index);
		var rightFree = this.areAllRightPositionsFree(index);
		var aboveFree = this.areAllAbovePositionsFree(index);
		var free = (leftFree || rightFree) && aboveFree;
		return free;
	},

	onTileClicked: function(tileDiv, tile, pos) {
		var self = this;
		console.log("Tile clicked: ", tile, pos)
		console.log("Free: "+this.canTileBeRemoved(pos.index));
		if(this.canTileBeRemoved(pos.index)) {
			// can remove tile...
			if(this.STATE == 0) {
				this.firstSelectedPos = pos;
				this.firstSelectedTile = tileDiv;
				tileDiv.addClass("selected");
				this.STATE = 1;
			} else if(this.STATE == 1) {
				if(pos.index == this.firstSelectedPos.index) {
					// we clicked on the same tile again...
					tileDiv.removeClass("selected");
					this.firstSelectedPos = null;
					this.firstSelectedTile = null;
					this.STATE = 0;
				} else {
					// we clicked on another tile
					this.secondSelectedPos = pos;
					this.secondSelectedTile = tileDiv;
					tileDiv.addClass("selected");
					this.STATE = 2;
					if(this.testTilesIfMatching(this.firstSelectedPos.occupiedBy, this.secondSelectedPos.occupiedBy)) {
						console.log("tiles do match!");
						setTimeout(function() {
							self.firstSelectedPos.occupiedBy = null;
							self.secondSelectedPos.occupiedBy = null;
							self.firstSelectedTile.remove();
							self.secondSelectedTile.remove();
							self.STATE = 0;
						}, self.highlightDuration);
					} else {
						console.log("tiles don't match!");
						this.firstSelectedTile.addClass("notmatching");
						this.secondSelectedTile.addClass("notmatching");
						setTimeout(function() {
							self.firstSelectedTile.removeClass("selected");
							self.secondSelectedTile.removeClass("selected");
							self.firstSelectedTile.removeClass("notmatching");
							self.secondSelectedTile.removeClass("notmatching");
							self.STATE = 0;
						}, self.highlightDuration);
					}
				}
			}
		}
	}


});